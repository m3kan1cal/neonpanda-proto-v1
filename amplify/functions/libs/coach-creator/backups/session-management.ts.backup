import { CoachCreatorSession, UserContext, Question, SophisticationLevel } from './types';
import { COACH_CREATOR_QUESTIONS, shouldSkipQuestion } from './question-management';
import { callBedrockApi, MODEL_IDS } from '../api-helpers';
import { JSON_FORMATTING_INSTRUCTIONS_STANDARD } from '../prompt-helpers';


// Factory function to create a new coach creator session with default values
// Generates unique session ID and initializes session state when user starts coach creator flow
export const createCoachCreatorSession = (userId: string): CoachCreatorSession => {
  const sessionId = `coach_creator_${userId}_${Date.now()}`;
  const now = new Date();

  return {
    userId,
    sessionId,
    userContext: {
      sophisticationLevel: 'UNKNOWN',
      responses: {},
      currentQuestion: 1,
      detectedSignals: [],
      sessionId,
      userId,
      startedAt: now,
      lastActivity: now
    },
    questionHistory: [],
    isComplete: false,
    startedAt: now,
    lastActivity: now
  };
};

// Calculate detailed progress information
export const getProgress = (userContext: UserContext) => {
  if (!COACH_CREATOR_QUESTIONS || !Array.isArray(COACH_CREATOR_QUESTIONS)) {
    console.error('COACH_CREATOR_QUESTIONS is not available or not an array');
    return {
      questionsCompleted: 0,
      totalQuestions: 0,
      percentage: 0
    };
  }

  const totalQuestions = COACH_CREATOR_QUESTIONS.filter((q: any) => !shouldSkipQuestion(q, userContext)).length;
  const questionsCompleted = Object.keys(userContext.responses).length;
  const percentage = totalQuestions > 0 ? Math.round((questionsCompleted / totalQuestions) * 100) : 0;

  return {
    questionsCompleted,
    totalQuestions,
    percentage
  };
};

// Generate coach creator session summary for analytics
export const generateCoachCreatorSessionSummary = (session: CoachCreatorSession): string => {
  const responses = session.userContext.responses;
  const sophistication = session.userContext.sophisticationLevel;

  const goals = responses['1'] || 'Not specified';
  const age = responses['2'] || 'Not specified';
  const experience = responses['3'] || 'Not specified';
  const frequency = responses['4'] || 'Not specified';
  const injuries = responses['5'] || 'None mentioned';
  const equipment = responses['6'] || 'Not specified';
  const movement = responses['7'] || 'Not specified';
  const coachingStyle = responses['8'] || 'Not specified';
  const success = responses['9'] || 'Not specified';
  const competition = responses['10'] || 'Not specified';

  return `User ${session.userId} completed coach creator as ${sophistication.toLowerCase()} level athlete. ` +
    `Goals: ${goals.slice(0, 100)}... | ` +
    `Age: ${age.slice(0, 50)}... | ` +
    `Experience: ${experience.slice(0, 100)}... | ` +
    `Training frequency: ${frequency.slice(0, 50)}... | ` +
    `Injuries/Limitations: ${injuries.slice(0, 100)}... | ` +
    `Equipment: ${equipment.slice(0, 100)}... | ` +
    `Movement focus: ${movement.slice(0, 100)}... | ` +
    `Coaching style: ${coachingStyle.slice(0, 100)}... | ` +
    `Success metrics: ${success.slice(0, 100)}... | ` +
    `Competition goals: ${competition.slice(0, 100)}... | ` +
    `Session completed with ${session.questionHistory.length} questions answered in ${session.userContext.sophisticationLevel} sophistication path.`;
};

// Store user response in session context, handling follow-up responses
export const storeUserResponse = (
  userContext: UserContext,
  currentQuestion: Question,
  userResponse: string
): UserContext => {
  const questionKey = currentQuestion.id.toString();
  const existingResponse = userContext.responses[questionKey];

  return {
    ...userContext,
    responses: {
      ...userContext.responses,
      [questionKey]: existingResponse
        ? `${existingResponse}\n\n[Follow-up]: ${userResponse}`
        : userResponse
    }
  };
};

// Add question interaction to session history
export const addQuestionHistory = (
  session: CoachCreatorSession,
  currentQuestion: Question,
  userResponse: string,
  aiResponse: string,
  detectedSophistication: string,
  imageS3Keys?: string[]
): void => {
  const historyEntry: any = {
    questionId: currentQuestion.id,
    userResponse,
    aiResponse,
    detectedSophistication,
    timestamp: new Date()
  };

  // Add image metadata if present
  if (imageS3Keys && imageS3Keys.length > 0) {
    historyEntry.imageS3Keys = imageS3Keys;
    historyEntry.messageType = 'text_with_images';
  }

  session.questionHistory.push(historyEntry);
};

/**
 * Check if user wants to finish the coach creator process using AI
 * Uses Claude Haiku for reliable intent detection with nuanced understanding
 *
 * @param userResponse - The user's response to the final question
 * @returns Promise<boolean> - True if user wants to finish and create the coach
 */
export const checkUserWantsToFinish = async (userResponse: string): Promise<boolean> => {
  const systemPrompt = `You are an AI that analyzes user responses in a coach creator onboarding flow.
Your task is to determine if the user wants to finish the questionnaire and create their custom AI coach.

The user has just completed the final question in the coach creator flow. Now you need to determine if they're ready to proceed with coach creation.

IMPORTANT CONTEXT:
- This is the FINAL question - they've already answered all previous questions
- They should be expressing readiness, confirmation, or willingness to proceed
- Look for affirmative signals, even subtle ones
- Consider both explicit statements ("yes", "ready") and implicit confirmation ("sounds good", "let's do it")

RESPOND "YES" IF:
- Expressing readiness or confirmation (e.g., "ready", "yes", "sure", "okay", "let's go")
- Showing enthusiasm or agreement (e.g., "sounds good", "perfect", "absolutely", "definitely")
- Indicating completion (e.g., "done", "finished", "all set", "that's it")
- Requesting action (e.g., "create the coach", "build it", "proceed", "let's create it")
- Being neutral but not objecting (e.g., "I think so", "probably", "I guess")

RESPOND "NO" IF:
- Expressing uncertainty or hesitation (e.g., "I'm not sure", "maybe not", "wait")
- Asking clarifying questions (e.g., "what happens next?", "can I change this later?")
- Indicating they need more time (e.g., "hold on", "let me think")
- Explicitly declining (e.g., "no", "not yet", "I want to stop")
- Requesting to go back or change answers

EDGE CASES:
- If the response is very short but affirmative (e.g., "yep", "ok", "sure"), respond YES
- If they're asking about what comes next in a positive way (e.g., "what's next?", "when will it be ready?"), respond YES
- When in doubt about a neutral response on the final question, lean toward YES (they've invested time to get here)

${JSON_FORMATTING_INSTRUCTIONS_STANDARD}

RESPONSE SCHEMA:
{
  "wantsToFinish": true or false,
  "confidence": 0.0 to 1.0,
  "reasoning": "brief explanation of your decision"
}`;

  const userPrompt = `User's response: "${userResponse}"

Does this user want to finish the coach creator and create their custom AI coach?`;

  // Use Claude Haiku for reliable intent detection
  console.info('ðŸ¤– Using AI to detect finish intent (Claude Haiku)');

  const response = await callBedrockApi(
    systemPrompt,
    userPrompt,
    MODEL_IDS.CLAUDE_HAIKU_4_FULL,
    false // No extended thinking needed for this classification
  );

  const result = JSON.parse(response.trim());

  console.info('âœ… AI finish intent detection result:', {
    userResponse: userResponse.substring(0, 100),
    wantsToFinish: result.wantsToFinish,
    confidence: result.confidence,
    reasoning: result.reasoning
  });

  return result.wantsToFinish;
};

// Update session context with new data
export const updateSessionContext = (
  userContext: UserContext,
  detectedLevel: SophisticationLevel | null,
  detectedSignals: string[],
  isOnFinalQuestion: boolean
): UserContext => {
  return {
    ...userContext,
    sophisticationLevel: detectedLevel || userContext.sophisticationLevel,
    currentQuestion: isOnFinalQuestion
      ? userContext.currentQuestion
      : userContext.currentQuestion + 1,
    detectedSignals: [...new Set([...userContext.detectedSignals, ...detectedSignals])],
    lastActivity: new Date()
  };
};

// Mark session as complete
export const markSessionComplete = (session: CoachCreatorSession): void => {
  session.isComplete = true;
  session.completedAt = new Date();
};
