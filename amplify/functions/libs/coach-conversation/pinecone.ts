/**
 * Coach Conversation Pinecone Integration
 *
 * This module handles storing and deleting coach conversation-related data in Pinecone
 * for semantic search and coach memory capabilities.
 */

import { deletePineconeContext, storePineconeContext } from "../api-helpers";
import {
  storeWithAutoCompression,
  deterministicCompressSummary,
  calculateMetadataSize,
  PINECONE_METADATA_LIMIT,
} from "../pinecone-compression";
import { CoachConversationSummary } from "./types";

/**
 * Store coach conversation summary in Pinecone for semantic search
 * Uses compact summary if available, with deterministic compression fallback
 * Only falls back to AI compression if deterministic compression is insufficient
 */
export async function storeCoachConversationSummaryInPinecone(
  summary: CoachConversationSummary & { compactSummary?: any },
): Promise<{ success: boolean; recordId?: string; error?: string }> {
  try {
    // Use compact summary if available (generated by AI in single pass)
    let summaryData = summary.compactSummary || {
      narrative: summary.narrative,
      current_goals: summary.structuredData.current_goals,
      recent_progress: summary.structuredData.recent_progress,
      preferences: summary.structuredData.preferences,
      methodology_preferences: summary.structuredData.methodology_preferences,
      emotional_state: summary.structuredData.emotional_state,
      key_insights: summary.structuredData.key_insights,
      important_context: summary.structuredData.important_context,
      conversation_tags: summary.structuredData.conversation_tags,
    };

    console.info("üìä Preparing summary for Pinecone:", {
      hasCompactSummary: !!summary.compactSummary,
      usingCompactVersion: !!summary.compactSummary,
    });

    // Create searchable content from summary data (compact or full)
    const searchableContent = `
${summaryData.narrative || ""}

Goals: ${summaryData.current_goals?.join(", ") || ""}
Recent Progress: ${summaryData.recent_progress?.join(", ") || ""}
Communication Style: ${summaryData.preferences?.communication_style || ""}
Training Preferences: ${summaryData.preferences?.training_preferences?.join(", ") || ""}
Schedule Constraints: ${summaryData.preferences?.schedule_constraints?.join(", ") || ""}
Methodology Preferences: ${summaryData.methodology_preferences?.mentioned_methodologies?.join(", ") || ""} | Preferred Approaches: ${summaryData.methodology_preferences?.preferred_approaches?.join(", ") || ""} | Questions: ${summaryData.methodology_preferences?.methodology_questions?.join(", ") || ""}
Emotional State: ${summaryData.emotional_state?.current_mood || ""} (motivation: ${summaryData.emotional_state?.motivation_level || ""}, confidence: ${summaryData.emotional_state?.confidence_level || ""})
Key Insights: ${summaryData.key_insights?.join(", ") || ""}
Important Context: ${summaryData.important_context?.join(", ") || ""}
Conversation Tags: ${summaryData.conversation_tags?.join(", ") || "none"}
    `.trim();

    // Create metadata for Pinecone
    const metadata = {
      recordType: "conversation_summary",
      type: "conversation_summary", // Keep for backwards compatibility
      // userId not needed here - storePineconeContext adds userId automatically
      coachId: summary.coachId,
      conversationId: summary.conversationId,
      summaryId: summary.summaryId,
      createdAt: summary.metadata.createdAt.toISOString(),
      messageCount: summary.metadata.messageRange.totalMessages,
      triggerReason: summary.metadata.triggerReason,
      confidence: summary.metadata.confidence,
      // Add structured data for filtering
      hasGoals: summary.structuredData.current_goals.length > 0,
      hasProgress: summary.structuredData.recent_progress.length > 0,
      hasEmotionalState: !!summary.structuredData.emotional_state.current_mood,
      hasInsights: summary.structuredData.key_insights.length > 0,
      hasMethodologyPreferences:
        summary.structuredData.methodology_preferences.mentioned_methodologies
          .length > 0 ||
        summary.structuredData.methodology_preferences.preferred_approaches
          .length > 0,
    };

    // Check size and apply deterministic compression if needed
    const initialSize = calculateMetadataSize(searchableContent, metadata);
    let finalContent = searchableContent;

    console.info("üìè Initial content size check:", {
      initialSize,
      limit: PINECONE_METADATA_LIMIT,
      utilizationPercent:
        Math.round((initialSize / PINECONE_METADATA_LIMIT) * 100) + "%",
      needsCompression: initialSize > PINECONE_METADATA_LIMIT,
    });

    // Apply deterministic compression if still too large
    // This avoids AI compression entirely for most cases
    if (initialSize > PINECONE_METADATA_LIMIT) {
      console.info(
        "üîß Applying deterministic compression to compact summary...",
      );
      const compressedData = deterministicCompressSummary(
        summaryData,
        PINECONE_METADATA_LIMIT * 0.8, // Target 80% of limit
      );

      // Rebuild searchable content with compressed data
      finalContent = `
${compressedData.narrative || ""}

Goals: ${compressedData.current_goals?.join(", ") || ""}
Recent Progress: ${compressedData.recent_progress?.join(", ") || ""}
Communication Style: ${compressedData.preferences?.communication_style || ""}
Training Preferences: ${compressedData.preferences?.training_preferences?.join(", ") || ""}
Schedule Constraints: ${compressedData.preferences?.schedule_constraints?.join(", ") || ""}
Methodology Preferences: ${compressedData.methodology_preferences?.mentioned_methodologies?.join(", ") || ""} | Preferred Approaches: ${compressedData.methodology_preferences?.preferred_approaches?.join(", ") || ""} | Questions: ${compressedData.methodology_preferences?.methodology_questions?.join(", ") || ""}
Emotional State: ${compressedData.emotional_state?.current_mood || ""} (motivation: ${compressedData.emotional_state?.motivation_level || ""}, confidence: ${compressedData.emotional_state?.confidence_level || ""})
Key Insights: ${compressedData.key_insights?.join(", ") || ""}
Important Context: ${compressedData.important_context?.join(", ") || ""}
Conversation Tags: ${compressedData.conversation_tags?.join(", ") || "none"}
      `.trim();

      const compressedSize = calculateMetadataSize(finalContent, metadata);
      console.info("‚úÖ Deterministic compression applied:", {
        originalSize: initialSize,
        compressedSize,
        reduction:
          Math.round(((initialSize - compressedSize) / initialSize) * 100) +
          "%",
        withinLimit: compressedSize <= PINECONE_METADATA_LIMIT,
      });

      // If STILL too large after deterministic compression, fall back to AI compression
      if (compressedSize > PINECONE_METADATA_LIMIT) {
        console.warn(
          "‚ö†Ô∏è Deterministic compression insufficient, falling back to AI compression",
        );
        await storeWithAutoCompression(
          (content) => storePineconeContext(summary.userId, content, metadata),
          finalContent,
          metadata,
          "conversation summary",
        );
      } else {
        // Direct storage - no AI needed!
        await storePineconeContext(summary.userId, finalContent, metadata);
      }
    } else {
      // Direct storage - already within limit
      await storePineconeContext(summary.userId, finalContent, metadata);
    }

    console.info("‚úÖ Conversation summary stored in Pinecone:", {
      pineconeId: summary.summaryId,
      summaryId: summary.summaryId,
      contentLength: finalContent.length,
      confidence: summary.metadata.confidence,
      usedCompactSummary: !!summary.compactSummary,
      appliedDeterministicCompression:
        initialSize > PINECONE_METADATA_LIMIT &&
        calculateMetadataSize(finalContent, metadata) <=
          PINECONE_METADATA_LIMIT,
      fellBackToAiCompression:
        initialSize > PINECONE_METADATA_LIMIT &&
        calculateMetadataSize(finalContent, metadata) > PINECONE_METADATA_LIMIT,
    });

    return { success: true, recordId: summary.summaryId };
  } catch (error) {
    console.error("‚ùå Error storing conversation summary in Pinecone:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * Delete conversation summary from Pinecone when conversation is deleted
 *
 * @param userId - The user ID for namespace targeting
 * @param conversationId - The conversation ID to delete from Pinecone
 * @returns Promise with deletion result
 */
export const deleteConversationSummaryFromPinecone = async (
  userId: string,
  conversationId: string,
): Promise<{ success: boolean; error?: string }> => {
  try {
    console.info("üóëÔ∏è Deleting conversation summary from Pinecone:", {
      userId,
      conversationId,
    });

    // Use centralized deletion function with conversation-specific filter
    const result = await deletePineconeContext(userId, {
      recordType: "conversation_summary",
      conversationId: conversationId,
    });

    if (result.success) {
      console.info(
        "‚úÖ Successfully deleted conversation summary from Pinecone:",
        {
          userId,
          conversationId,
          deletedRecords: result.deletedCount,
        },
      );
    } else {
      console.warn("‚ö†Ô∏è Failed to delete conversation summary from Pinecone:", {
        userId,
        conversationId,
        error: result.error,
      });
    }

    return {
      success: result.success,
      error: result.error,
    };
  } catch (error) {
    console.error(
      "‚ùå Failed to delete conversation summary from Pinecone:",
      error,
    );

    // Don't throw error to avoid breaking the conversation deletion process
    // Pinecone cleanup failure shouldn't prevent DynamoDB deletion
    console.warn(
      "Conversation deletion will continue despite Pinecone cleanup failure",
    );
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
};
