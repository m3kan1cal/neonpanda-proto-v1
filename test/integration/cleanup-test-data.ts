#!/usr/bin/env tsx

/**
 * Cleanup Test Data Script
 *
 * Reads test result JSON files generated by test-build-workout.ts and
 * test-build-program.ts, then deletes the created entities via their
 * respective delete Lambda functions.
 *
 * The delete Lambdas handle the full cleanup chain:
 *   - delete-workout: DynamoDB + Pinecone (workout_summary)
 *   - delete-program: DynamoDB + S3 (workout templates) + Pinecone (program_summary)
 *
 * Usage:
 *   tsx test/integration/cleanup-test-data.ts <dir1> [dir2 ...] [options]
 *
 * Arguments:
 *   dir1, dir2, ...   One or more directories containing test result JSON files
 *
 * Options:
 *   --dry-run           Show what would be deleted without actually deleting
 *   --auto-confirm      Skip confirmation prompt
 *   --verbose           Show detailed progress and Lambda responses
 *   --region=REGION     AWS region (default: us-west-2)
 *   --delete-workout=NAME   Override delete-workout Lambda function name
 *   --delete-program=NAME   Override delete-program Lambda function name
 *
 * Examples:
 *   tsx test/integration/cleanup-test-data.ts test/fixtures/workout-results --dry-run
 *   tsx test/integration/cleanup-test-data.ts test/fixtures/workout-results test/fixtures/program-results
 *   tsx test/integration/cleanup-test-data.ts test/fixtures/workout-results --auto-confirm --verbose
 */

import { LambdaClient, InvokeCommand } from "@aws-sdk/client-lambda";
import * as fs from "fs";
import * as path from "path";
import readline from "readline";

// Configuration
const DEFAULT_REGION = "us-west-2";

// Lambda function names (matching deployed sandbox environment)
// To find the delete-program name, run:
//   aws lambda list-functions --region us-west-2 \
//     --query "Functions[?contains(FunctionName, 'deleteprogram')].FunctionName" --output text
const LAMBDA_FUNCTION_NAMES = {
  deleteWorkout:
    "amplify-neonpandaprotov1--deleteworkoutlambda15FBE-k79HpBzKYXAZ",
  deleteProgram:
    "amplify-neonpandaprotov1--deleteprogramlambda205E00-REPLACE_ME",
};

// Known test user ID (both test scripts use this)
const TEST_USER_ID = "63gocaz-j-AYRsb0094ik";
const TEST_COACH_ID = "user_63gocaz-j-AYRsb0094ik_coach_1756078034317";

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface CleanupOptions {
  directories: string[];
  dryRun: boolean;
  autoConfirm: boolean;
  verbose: boolean;
  region: string;
  deleteWorkoutFunction: string;
  deleteProgramFunction: string;
}

interface EntityToDelete {
  type: "workout" | "program";
  id: string;
  userId: string;
  coachId?: string;
  testName: string;
  sourceFile: string;
  passed?: boolean;
}

interface DeleteResult {
  entity: EntityToDelete;
  success: boolean;
  error?: string;
  pineconeCleanup?: boolean;
}

// â”€â”€â”€ Argument Parsing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function parseArgs(): CleanupOptions {
  const args = process.argv.slice(2);

  if (args.length === 0 || args[0] === "--help" || args[0] === "-h") {
    console.info(`
Cleanup Test Data Script

Reads test result JSON files from test-build-workout.ts and
test-build-program.ts output directories, then deletes the
created entities via their respective delete Lambda functions.

Delete Lambdas handle the full cleanup chain:
  - delete-workout: DynamoDB + Pinecone (workout_summary)
  - delete-program: DynamoDB + S3 (templates) + Pinecone (program_summary)

Usage:
  tsx test/integration/cleanup-test-data.ts <dir1> [dir2 ...] [options]

Arguments:
  dir1, dir2, ...   One or more directories containing *_result.json files

Options:
  --dry-run               Show what would be deleted without actually deleting
  --auto-confirm          Skip confirmation prompt
  --verbose               Show detailed progress and Lambda responses
  --region=REGION         AWS region (default: ${DEFAULT_REGION})
  --delete-workout=NAME   Override delete-workout Lambda function name
  --delete-program=NAME   Override delete-program Lambda function name
  --help, -h              Show this help message

Examples:
  tsx test/integration/cleanup-test-data.ts test/fixtures/workout-results --dry-run
  tsx test/integration/cleanup-test-data.ts test/fixtures/workout-results test/fixtures/program-results
  tsx test/integration/cleanup-test-data.ts test/fixtures/workout-results --auto-confirm --verbose
    `);
    process.exit(0);
  }

  const options: CleanupOptions = {
    directories: [],
    dryRun: false,
    autoConfirm: false,
    verbose: false,
    region: DEFAULT_REGION,
    deleteWorkoutFunction: LAMBDA_FUNCTION_NAMES.deleteWorkout,
    deleteProgramFunction: LAMBDA_FUNCTION_NAMES.deleteProgram,
  };

  for (const arg of args) {
    if (arg === "--dry-run") {
      options.dryRun = true;
    } else if (arg === "--auto-confirm") {
      options.autoConfirm = true;
    } else if (arg === "--verbose") {
      options.verbose = true;
    } else if (arg.startsWith("--region=")) {
      options.region = arg.split("=")[1];
    } else if (arg.startsWith("--delete-workout=")) {
      options.deleteWorkoutFunction = arg.split("=")[1];
    } else if (arg.startsWith("--delete-program=")) {
      options.deleteProgramFunction = arg.split("=")[1];
    } else if (!arg.startsWith("--")) {
      options.directories.push(arg);
    }
  }

  if (options.directories.length === 0) {
    console.error("âŒ Error: at least one output directory is required");
    console.error("   Run with --help for usage information");
    process.exit(1);
  }

  return options;
}

// â”€â”€â”€ Result File Scanning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Scan directories for test result JSON files and extract entity IDs.
 *
 * Handles two formats:
 *   - Workout results: { result: { workoutId, success } }
 *   - Program results: { response: { body: "{ programId, success }" } }
 *     OR: { parsedBody: { programId, success } }
 */
function scanResultFiles(directories: string[]): EntityToDelete[] {
  const entities: EntityToDelete[] = [];
  const seenIds = new Set<string>();

  for (const dir of directories) {
    if (!fs.existsSync(dir)) {
      console.warn(`âš ï¸  Directory not found: ${dir}`);
      continue;
    }

    const files = fs
      .readdirSync(dir)
      .filter((f) => f.endsWith("_result.json"))
      .sort();

    for (const file of files) {
      const filePath = path.join(dir, file);
      try {
        const data = JSON.parse(fs.readFileSync(filePath, "utf-8"));

        // Try to extract workout entity
        const workoutId = data.result?.workoutId;
        if (workoutId && !seenIds.has(workoutId)) {
          seenIds.add(workoutId);
          entities.push({
            type: "workout",
            id: workoutId,
            userId: TEST_USER_ID,
            testName: data.testName || file,
            sourceFile: filePath,
            passed: data.passed,
          });
          continue;
        }

        // Try to extract program entity (format 1: parsedBody)
        const parsedBody = data.parsedBody;
        if (parsedBody?.programId && !seenIds.has(parsedBody.programId)) {
          seenIds.add(parsedBody.programId);
          entities.push({
            type: "program",
            id: parsedBody.programId,
            userId: TEST_USER_ID,
            coachId: TEST_COACH_ID,
            testName: data.testName || file,
            sourceFile: filePath,
            passed: data.passed,
          });
          continue;
        }

        // Try to extract program entity (format 2: response.body string)
        const responseBody = data.response?.body;
        if (responseBody) {
          const body =
            typeof responseBody === "string"
              ? JSON.parse(responseBody)
              : responseBody;
          if (body?.programId && !seenIds.has(body.programId)) {
            seenIds.add(body.programId);
            entities.push({
              type: "program",
              id: body.programId,
              userId: TEST_USER_ID,
              coachId: TEST_COACH_ID,
              testName: data.testName || file,
              sourceFile: filePath,
              passed: data.passed,
            });
            continue;
          }
        }

        // No entity ID found (likely a failed/skipped test -- nothing to clean up)
      } catch (error) {
        console.warn(
          `âš ï¸  Could not parse ${filePath}: ${(error as Error).message}`,
        );
      }
    }
  }

  return entities;
}

// â”€â”€â”€ Lambda Invocation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Create an authenticated event for direct Lambda invocation.
 * Uses pathParameters.userId for internal auth (allowInternalCalls: true).
 */
function createAuthenticatedEvent(
  userId: string,
  pathParams: Record<string, string> = {},
  queryParams: Record<string, string> = {},
) {
  return {
    pathParameters: {
      userId,
      ...pathParams,
    },
    queryStringParameters: queryParams,
    requestContext: {
      http: {
        method: "DELETE",
      },
    },
  };
}

/**
 * Delete a workout via the delete-workout Lambda.
 * The Lambda handles: DynamoDB delete + Pinecone workout_summary cleanup.
 */
async function deleteWorkoutEntity(
  client: LambdaClient,
  functionName: string,
  entity: EntityToDelete,
  verbose: boolean,
): Promise<DeleteResult> {
  const event = createAuthenticatedEvent(entity.userId, {
    workoutId: entity.id,
  });

  try {
    const command = new InvokeCommand({
      FunctionName: functionName,
      Payload: JSON.stringify(event),
    });

    const response = await client.send(command);
    const result = JSON.parse(new TextDecoder().decode(response.Payload));
    const body =
      typeof result.body === "string" ? JSON.parse(result.body) : result.body;

    if (result.statusCode && result.statusCode >= 400) {
      const errorMsg =
        body?.error || body?.message || `HTTP ${result.statusCode}`;
      if (verbose) {
        console.info(`  âŒ ${entity.id}: ${errorMsg}`);
      }
      return { entity, success: false, error: errorMsg };
    }

    if (verbose) {
      console.info(
        `  âœ… ${entity.id} (Pinecone: ${body?.pineconeCleanup ? "cleaned" : "skipped"})`,
      );
    }

    return {
      entity,
      success: true,
      pineconeCleanup: body?.pineconeCleanup,
    };
  } catch (error) {
    const errorMsg = (error as Error).message;
    if (verbose) {
      console.info(`  âŒ ${entity.id}: ${errorMsg}`);
    }
    return { entity, success: false, error: errorMsg };
  }
}

/**
 * Delete a program via the delete-program Lambda with hardDelete=true.
 * The Lambda handles: DynamoDB delete + S3 template delete + Pinecone program_summary cleanup.
 */
async function deleteProgramEntity(
  client: LambdaClient,
  functionName: string,
  entity: EntityToDelete,
  verbose: boolean,
): Promise<DeleteResult> {
  const event = createAuthenticatedEvent(
    entity.userId,
    {
      coachId: entity.coachId || TEST_COACH_ID,
      programId: entity.id,
    },
    {
      hardDelete: "true", // Hard delete -- removes from DynamoDB, S3, and Pinecone
    },
  );

  try {
    const command = new InvokeCommand({
      FunctionName: functionName,
      Payload: JSON.stringify(event),
    });

    const response = await client.send(command);
    const result = JSON.parse(new TextDecoder().decode(response.Payload));
    const body =
      typeof result.body === "string" ? JSON.parse(result.body) : result.body;

    if (result.statusCode && result.statusCode >= 400) {
      const errorMsg =
        body?.error || body?.message || `HTTP ${result.statusCode}`;
      if (verbose) {
        console.info(`  âŒ ${entity.id}: ${errorMsg}`);
      }
      return { entity, success: false, error: errorMsg };
    }

    if (verbose) {
      console.info(`  âœ… ${entity.id} (hard deleted)`);
    }

    return { entity, success: true };
  } catch (error) {
    const errorMsg = (error as Error).message;
    if (verbose) {
      console.info(`  âŒ ${entity.id}: ${errorMsg}`);
    }
    return { entity, success: false, error: errorMsg };
  }
}

// â”€â”€â”€ Display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function displayEntities(entities: EntityToDelete[]) {
  const workouts = entities.filter((e) => e.type === "workout");
  const programs = entities.filter((e) => e.type === "program");

  console.info("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  console.info("ENTITIES TO DELETE");
  console.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

  if (workouts.length > 0) {
    console.info(`ğŸ“‹ Workouts (${workouts.length}):`);
    workouts.forEach((e, i) => {
      const status = e.passed ? "âœ…" : "âŒ";
      console.info(`  ${i + 1}. ${status} ${e.id}`);
      console.info(`     Test: ${e.testName}`);
    });
    console.info("");
  }

  if (programs.length > 0) {
    console.info(`ğŸ“‹ Programs (${programs.length}):`);
    programs.forEach((e, i) => {
      const status = e.passed ? "âœ…" : "âŒ";
      console.info(`  ${i + 1}. ${status} ${e.id}`);
      console.info(`     Test: ${e.testName}`);
    });
    console.info("");
  }

  console.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  console.info(
    `Total: ${entities.length} entities (${workouts.length} workouts, ${programs.length} programs)`,
  );
  console.info("Delete chain: DynamoDB + S3 (programs) + Pinecone summaries");
  console.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}

// â”€â”€â”€ Confirmation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function confirm(message: string): Promise<boolean> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question(message, (answer) => {
      rl.close();
      resolve(answer.toLowerCase() === "y" || answer.toLowerCase() === "yes");
    });
  });
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function main() {
  console.info("ğŸ§¹ Test Data Cleanup Script\n");

  const options = parseArgs();

  console.info("Configuration:");
  console.info(`  Directories: ${options.directories.join(", ")}`);
  console.info(`  Region: ${options.region}`);
  console.info(`  Dry Run: ${options.dryRun}`);
  console.info(`  Verbose: ${options.verbose}`);

  // 1. Scan result files
  console.info("\nğŸ“‚ Scanning result files...");
  const entities = scanResultFiles(options.directories);

  if (entities.length === 0) {
    console.info(
      "\nâœ… No entities found in result files. Nothing to clean up.\n",
    );
    return;
  }

  // 2. Display what will be deleted
  displayEntities(entities);

  // 3. Dry run check
  if (options.dryRun) {
    console.info("ğŸ” DRY RUN: No entities were deleted");
    console.info("   Remove --dry-run flag to actually delete entities\n");
    return;
  }

  // 4. Confirmation
  if (!options.autoConfirm) {
    const confirmed = await confirm(
      `âš ï¸  Are you sure you want to permanently delete ${entities.length} entities? (y/N): `,
    );
    if (!confirmed) {
      console.info("\nâŒ Deletion cancelled by user\n");
      return;
    }
  }

  // 5. Execute deletions
  const lambdaClient = new LambdaClient({ region: options.region });

  console.info("\nğŸ—‘ï¸  Deleting entities...\n");

  const workouts = entities.filter((e) => e.type === "workout");
  const programs = entities.filter((e) => e.type === "program");

  const results: DeleteResult[] = [];

  // Delete workouts
  if (workouts.length > 0) {
    console.info(`Deleting ${workouts.length} workouts...`);
    for (const entity of workouts) {
      const result = await deleteWorkoutEntity(
        lambdaClient,
        options.deleteWorkoutFunction,
        entity,
        options.verbose,
      );
      results.push(result);

      if (!options.verbose) {
        process.stdout.write(result.success ? "." : "x");
      }

      // Small delay to avoid throttling
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
    if (!options.verbose) console.info("");
  }

  // Delete programs
  if (programs.length > 0) {
    console.info(`Deleting ${programs.length} programs...`);
    for (const entity of programs) {
      const result = await deleteProgramEntity(
        lambdaClient,
        options.deleteProgramFunction,
        entity,
        options.verbose,
      );
      results.push(result);

      if (!options.verbose) {
        process.stdout.write(result.success ? "." : "x");
      }

      // Small delay to avoid throttling
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
    if (!options.verbose) console.info("");
  }

  // 6. Summary
  const succeeded = results.filter((r) => r.success).length;
  const failed = results.filter((r) => !r.success).length;

  console.info("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  console.info(`âœ… Successfully deleted: ${succeeded}`);
  if (failed > 0) {
    console.info(`âŒ Failed to delete: ${failed}`);
    console.info("\nFailures:");
    results
      .filter((r) => !r.success)
      .forEach((r) => {
        console.info(`  - ${r.entity.type} ${r.entity.id}: ${r.error}`);
      });
  }
  console.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

  if (failed > 0) {
    process.exit(1);
  }
}

// Run
main().catch((error) => {
  console.error("âŒ Fatal error:", error);
  process.exit(1);
});
